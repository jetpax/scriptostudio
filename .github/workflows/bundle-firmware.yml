# Bundle Firmware Workflow
# Merges firmware components (from pyDirect) with VFS device-scripts into deployable .bin files
#
# Triggers:
#   - Push to boards/firmware/components/** (new firmware from pyDirect CI)
#   - Push to boards/firmware/device-scripts/** (VFS content changes)
#   - Manual trigger

name: Bundle Firmware

on:
  push:
    paths:
      - 'boards/firmware/components/**'
      - 'boards/firmware/device-scripts/**'
    branches: [main]
  workflow_dispatch:

jobs:
  bundle:
    name: Build merged firmware
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout scriptostudio
        uses: actions/checkout@v4

      - name: Install tools
        run: |
          # Install mklittlefs
          wget -q https://github.com/earlephilhower/mklittlefs/releases/download/4.1.0/x86_64-linux-gnu-mklittlefs-42acb97.tar.gz
          tar -xzf x86_64-linux-gnu-mklittlefs-42acb97.tar.gz --strip-components=1
          sudo mv mklittlefs /usr/local/bin/
          chmod +x /usr/local/bin/mklittlefs

          # Install esptool
          pip install esptool

      - name: Verify components exist
        run: |
          COMPONENTS="boards/firmware/components"
          if [ ! -d "$COMPONENTS" ] || [ -z "$(ls -A $COMPONENTS 2>/dev/null)" ]; then
            echo "âŒ No firmware components found in $COMPONENTS"
            echo "   Components are pushed by pyDirect CI. Run the pyDirect build first."
            exit 1
          fi
          echo "ðŸ“¦ Found variants:"
          ls -1 "$COMPONENTS"

      - name: List VFS contents
        run: |
          echo "ðŸ“‚ Device scripts to be bundled into VFS:"
          find boards/firmware/device-scripts -type f | sort
          echo ""
          echo "ðŸ“Š Total files: $(find boards/firmware/device-scripts -type f | wc -l)"

      - name: Build merged firmware for each variant
        run: |
          COMPONENTS="boards/firmware/components"
          DEVICE_SCRIPTS="boards/firmware/device-scripts"
          FIRMWARE_DIR="boards/firmware"

          for variant_dir in "$COMPONENTS"/*/; do
            VARIANT=$(basename "$variant_dir")
            echo "ðŸ“¦ Processing variant: $VARIANT"

            BOOTLOADER="$variant_dir/bootloader.bin"
            PARTITION_TABLE="$variant_dir/partition-table.bin"
            FIRMWARE="$variant_dir/micropython.bin"
            PARTITION_CSV=$(find "$variant_dir" -name "partitions*.csv" | head -1)

            # Verify all components present
            for f in "$BOOTLOADER" "$PARTITION_TABLE" "$FIRMWARE" "$PARTITION_CSV"; do
              if [ ! -f "$f" ]; then
                echo "âŒ Missing: $f"
                exit 1
              fi
            done

            # Parse VFS partition offset and size from CSV
            VFS_LINE=$(grep "^vfs," "$PARTITION_CSV")
            VFS_OFFSET=$(echo "$VFS_LINE" | cut -d',' -f4 | xargs)
            VFS_SIZE=$(echo "$VFS_LINE" | cut -d',' -f5 | xargs)

            if [[ "$VFS_SIZE" == 0x* ]]; then
              VFS_SIZE=$((VFS_SIZE))
            fi

            echo "  VFS offset: $VFS_OFFSET, size: $VFS_SIZE bytes"

            # Create VFS partition from device-scripts
            VFS_IMAGE="/tmp/vfs-${VARIANT}.bin"
            mklittlefs \
              -c "$DEVICE_SCRIPTS" \
              -b 4096 -p 256 \
              -s "$VFS_SIZE" \
              "$VFS_IMAGE"

            echo "  âœ… VFS image: $(du -h "$VFS_IMAGE" | cut -f1)"

            # Detect chip and flash size from variant name
            CHIP="esp32s3"
            if [[ "$VARIANT" == *"P4"* ]]; then CHIP="esp32p4"; fi

            # Detect flash size from variant suffix (ESP32_S3_8=8MB, ESP32_S3_16=16MB, etc.)
            FLASH_MB=$(echo "$VARIANT" | grep -oE '[0-9]+$')
            FLASH_SIZE="${FLASH_MB}MB"

            # Detect bootloader offset (P4 uses 0x2000, others use 0x0)
            BOOT_OFFSET="0x0"
            if [[ "$CHIP" == "esp32p4" ]]; then
              BOOT_OFFSET="0x2000"
            fi

            # Merge all parts into deployable firmware (output to /tmp, not repo)
            MERGED="/tmp/${VARIANT}-merged.bin"
            esptool.py --chip "$CHIP" merge_bin \
              --fill-flash-size "$FLASH_SIZE" \
              --flash_mode dio \
              --flash_freq 80m \
              --flash_size "$FLASH_SIZE" \
              -o "$MERGED" \
              $BOOT_OFFSET "$BOOTLOADER" \
              0x8000 "$PARTITION_TABLE" \
              0x10000 "$FIRMWARE" \
              $VFS_OFFSET "$VFS_IMAGE"

            echo "  âœ… Created: $MERGED ($(du -h "$MERGED" | cut -f1))"
          done

      - name: Determine version
        id: version
        run: |
          BUILD_INFO="boards/firmware/components/build-info.json"
          if [ -f "$BUILD_INFO" ]; then
            VERSION=$(python3 -c "import json; print(json.load(open('$BUILD_INFO'))['version'])")
            COMMIT=$(python3 -c "import json; print(json.load(open('$BUILD_INFO'))['commit'])")
          else
            VERSION="unknown"
            COMMIT="${{ github.sha }}"
          fi
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "commit=$COMMIT" >> "$GITHUB_OUTPUT"
          TAG="firmware-${VERSION}-$(date -u +%Y%m%d%H%M%S)"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"

      - name: Create firmware release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.tag }}
          name: "Firmware ${{ steps.version.outputs.version }}"
          body: |
            Firmware build from pyDirect commit `${{ steps.version.outputs.commit }}`
            Built: ${{ github.event.head_commit.timestamp || github.event.repository.updated_at }}
          files: /tmp/*-merged.bin
          make_latest: true

      - name: Build latest.json with CORS-friendly URLs
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          COMMIT="${{ steps.version.outputs.commit }}"
          TAG="${{ steps.version.outputs.tag }}"
          REPO="${{ github.repository }}"

          # Wait for release assets to be available
          sleep 5

          # Query the GitHub API to get asset download URLs
          # The api.github.com asset endpoint supports CORS (unlike github.com/releases/download/)
          RELEASE_JSON=$(gh api "repos/${REPO}/releases/tags/${TAG}")
          
          # Build variant entries with CORS-friendly API URLs
          # Format: https://api.github.com/repos/{owner}/{repo}/releases/assets/{id}
          # The flasher will fetch with Accept: application/octet-stream header
          VARIANTS="["
          FIRST=true
          for VARIANT_ID in ESP32_S3_8 ESP32_S3_16 ESP32_P4_16 ESP32_P4_32; do
            FILE="${VARIANT_ID}-merged.bin"
            CHIP="esp32s3"
            FLASH="8MB"
            if [[ "$VARIANT_ID" == *"P4"* ]]; then CHIP="esp32p4"; fi
            if [[ "$VARIANT_ID" == *"_16" ]]; then FLASH="16MB"; fi
            if [[ "$VARIANT_ID" == *"_32" ]]; then FLASH="32MB"; fi

            # Get asset ID from release JSON
            ASSET_ID=$(echo "$RELEASE_JSON" | python3 -c "
          import json, sys
          data = json.load(sys.stdin)
          for asset in data.get('assets', []):
              if asset['name'] == '$FILE':
                  print(asset['id'])
                  break
          " 2>/dev/null || echo "")

            if [ -n "$ASSET_ID" ]; then
              API_URL="https://api.github.com/repos/${REPO}/releases/assets/${ASSET_ID}"
              BROWSER_URL="https://github.com/${REPO}/releases/download/${TAG}/${FILE}"
              if [ "$FIRST" = true ]; then FIRST=false; else VARIANTS="$VARIANTS,"; fi
              VARIANTS="$VARIANTS
              { \"id\": \"${VARIANT_ID}\", \"chip\": \"${CHIP}\", \"flash\": \"${FLASH}\", \"file\": \"${FILE}\", \"url\": \"${API_URL}\", \"browser_url\": \"${BROWSER_URL}\" }"
            else
              echo "âš ï¸  Asset not found for $FILE â€” skipping"
            fi
          done
          VARIANTS="$VARIANTS
            ]"

          cat > boards/firmware/latest.json << EOF
          {
            "version": "$VERSION",
            "updated": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "pyDirect_commit": "$COMMIT",
            "scriptostudio_commit": "${{ github.sha }}",
            "release_tag": "$TAG",
            "release_url": "https://github.com/${REPO}/releases/tag/${TAG}",
            "variants": $VARIANTS
          }
          EOF

          echo "ðŸ“‹ Generated latest.json:"
          cat boards/firmware/latest.json

      - name: Commit latest.json
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add boards/firmware/latest.json
          git commit -m "ðŸ¤– Firmware ${{ steps.version.outputs.version }} â€” release ${{ steps.version.outputs.tag }}" || echo "No changes"
          git push
