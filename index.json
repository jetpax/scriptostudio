{
  "v": 1,
  "updated": 1763184231,
  "scriptos": [
    {
      "name": "1-Wire Devices Scan",
      "filename": "1-Wire Slaves Scan.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "JC`zic",
      "description": "Initializes a 1-Wire bus on a single GPIO and finds all the family IDs and serial numbers of slave devices.",
      "category": "Communication",
      "tags": [
        "communication"
      ],
      "license": "MIT",
      "docs": "https://github.com/jczic",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/1-Wire%20Slaves%20Scan.py"
    },
    {
      "name": "ADC Reader",
      "filename": "ADC Reader.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "JC`zic",
      "description": " Simple level and voltage reader on a GPIO using an analog-to-digital converter (ADC).\n                          You can specify the dB applied attenuation and the bits resolution.\n                      ",
      "category": "Hardware",
      "tags": [
        "hardware"
      ],
      "license": "MIT",
      "docs": "https://github.com/jczic",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/ADC%20Reader.py"
    },
    {
      "name": "Adafruit Circuitpython Ssd1306",
      "filename": "Adafruit Circuitpython Ssd1306.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "adafruit",
      "description": "Introduction ============",
      "category": "Display",
      "tags": [
        "display",
        "untested",
        "awesome-micropython"
      ],
      "license": "MIT",
      "source_url": "https://github.com/adafruit/Adafruit_CircuitPython_SSD1306",
      "source_repo": "adafruit/Adafruit_CircuitPython_SSD1306",
      "upstream_version": "2.12.22",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/Adafruit%20Circuitpython%20Ssd1306.py"
    },
    {
      "name": "BLE Scan",
      "filename": "BLE Scan.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "JC`zic",
      "description": "Initializes the Bluetooth Low Energy radio and scans BLE devices via advertising data.",
      "category": "Network",
      "tags": [
        "network"
      ],
      "license": "MIT",
      "docs": "https://github.com/jczic",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/BLE%20Scan.py"
    },
    {
      "name": "BLE iBeacon",
      "filename": "BLE iBeacon.py",
      "version": [
        2,
        0,
        0
      ],
      "author": "JC`zic",
      "description": "Initializes the Bluetooth Low Energy radio and simulates an Apple iBeacon object. The advertising message broadcasts an UUID corresponding to \"B.SCRIPTO_BEACON\" in binary with the short name \"ScriptOmator\" while the iBeacon is the response to an active scanner.\nThe iBeacon (Apple beacon format) data are:\nMajor = 123  /  Minor = 456  /  TX at 1 meter = -55 dB",
      "category": "Network",
      "tags": [
        "network"
      ],
      "license": "MIT",
      "docs": "https://github.com/jczic",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/BLE%20iBeacon.py"
    },
    {
      "name": "CAN/TWAI Loopback Test",
      "filename": "CAN Loopback Test.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "Scriptomatic Team",
      "description": "Test the CAN/TWAI module with internal loopback mode. This test verifies that the CAN module is properly integrated and working. No external hardware is required - the test uses internal loopback mode within the ESP32's TWAI controller. For real CAN bus communication with OpenInverter, you'll need: A CAN transceiver (SN65HVD230 recommended for 3.3V), 120Ω termination resistors at both ends of the bus, and use mode=NORMAL instead of LOOPBACK.",
      "category": "CAN/TWAI",
      "tags": [
        "can/twai"
      ],
      "license": "MIT",
      "docs": "https://github.com/straga/micropython-esp32-twai",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/CAN%20Loopback%20Test.py"
    },
    {
      "name": "DAC Output",
      "filename": "DAC Output.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "JC`zic",
      "description": "Set a GPIO output to a specific voltage using digital-to-analog converter (DAC).",
      "category": "Hardware",
      "tags": [
        "hardware"
      ],
      "license": "MIT",
      "docs": "https://github.com/jczic",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/DAC%20Output.py"
    },
    {
      "name": "GPIO Input",
      "filename": "GPIO Input.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "JC`zic",
      "description": " Simple reader of low/high voltage signals on a GPIO (pin) input.\n                          You can enable an internal pull resistor or not.\n                      ",
      "category": "Hardware",
      "tags": [
        "hardware"
      ],
      "license": "MIT",
      "docs": "https://github.com/jczic",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/GPIO%20Input.py"
    },
    {
      "name": "GPIO Output",
      "filename": "GPIO Output.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "JC`zic",
      "description": "Set a GPIO (pin) output to ON or OFF.",
      "category": "Hardware",
      "tags": [
        "hardware"
      ],
      "license": "MIT",
      "docs": "https://github.com/jczic",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/GPIO%20Output.py"
    },
    {
      "name": "I2C Slaves Scan",
      "filename": "I2C Slaves Scan.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "JC`zic",
      "description": " Initializes an I2C bus on two GPIO and scans it to find all the addresses of I2C slaves.\n                          You can choose the bus identifier, the SCL and SDA GPIO as well as the frequency in MHz.\n                      ",
      "category": "Communication",
      "tags": [
        "communication"
      ],
      "license": "MIT",
      "docs": "https://github.com/jczic",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/I2C%20Slaves%20Scan.py"
    },
    {
      "name": "KT403A MP3 Player",
      "filename": "KT403A MP3 Player.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "JC`zic",
      "description": "For MP3 modules based on KT403A chipset like DFPlayer, Grove-MP3 v2 and more.\nYou will be able to connect your board via an UART bus, play all the sound files in loop from the intended storage source (microSD, USB, flash memory), adjust the volume but also choose an audio EQ effect (normal, pop, rock, jazz, classic, bass). Info: KT403A supports MP3 & WAV audio formats on FAT16 or FAT32 files system, 32 GB max for microSD.",
      "category": "Hardware",
      "tags": [
        "hardware"
      ],
      "license": "MIT",
      "docs": "https://github.com/jczic",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/KT403A%20MP3%20Player.py"
    },
    {
      "name": "LEDs - DotStar RGB Strip",
      "filename": "LEDs - DotStar Strip.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "JC`zic for the colors demo\nDamien P. George, Ladyada, Scott Shawcroft and Matt Trentini for the DotStar lib",
      "description": "Try your DotStar RGB LEDs via SPI bus, compatible with strips APA102, SK9822, and more. You can choose the number of LEDs as well as the bus connectivity settings and the lighting in full power or in fading rainbow. The embedded library can be found via the link below.",
      "category": "Hardware",
      "tags": [
        "hardware"
      ],
      "license": "MIT",
      "docs": "https://github.com/mattytrentini/micropython-dotstar",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/LEDs%20-%20DotStar%20Strip.py"
    },
    {
      "name": "LEDs - NeoPixel RGB(+W/Y) Strip (Interruptible)",
      "filename": "LEDs - NeoPixel Strip.py",
      "version": [
        1,
        1,
        0
      ],
      "author": "jetPax from code by JC`zic",
      "description": "NeoPixel RGB LEDs demo, compatible with strips WS2812(B), SK6812, ADAxxxx, APA106, FLORA and more. You can choose rainbow fade animation or static white, as well as the number and type of LEDs, brightness, fade speed, RGB protocol and LED frequency. The script is interruptible and can be stopped with the Stop button or disconnect. The NeoPixel library was coded by Damien P. George.",
      "category": "Hardware",
      "tags": [
        "hardware"
      ],
      "license": "MIT",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/LEDs%20-%20NeoPixel%20Strip.py"
    },
    {
      "name": "Magnet Sensor",
      "filename": "Magnet Sensor.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "JC`zic",
      "description": "Allows to test the hall sensor of the ESP32 chip with detection of the two magnetic poles after automatic calibration.",
      "category": "Hardware",
      "tags": [
        "hardware"
      ],
      "license": "MIT",
      "docs": "https://github.com/jczic",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/Magnet%20Sensor.py"
    },
    {
      "name": "Max Threads",
      "filename": "Max Threads.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "JC`zic",
      "description": "Returns the maximum number of possible threads to create with the configurable stack size.",
      "category": "System",
      "tags": [
        "system"
      ],
      "license": "MIT",
      "docs": "https://github.com/jczic",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/Max%20Threads.py"
    },
    {
      "name": "Memory Check",
      "filename": "Memory Check.py",
      "version": [
        2,
        0,
        0
      ],
      "author": "jetpax",
      "description": "WebREPL-safe memory test. Checks available RAM and tests it by allocating a specified size of memory.",
      "category": "System",
      "tags": [
        "system"
      ],
      "license": "MIT",
      "docs": "https://github.com/jetpax",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/Memory%20Check.py"
    },
    {
      "name": "Micropython Mqtt",
      "filename": "Micropython Mqtt.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "peterhinch",
      "description": "MQTT is an easily used networking protocol designed for IOT (internet of things) applications. It is well suited for controlling hardware devices and",
      "category": "Communications",
      "tags": [
        "communications",
        "untested",
        "awesome-micropython"
      ],
      "license": "MIT",
      "source_url": "https://github.com/peterhinch/micropython-mqtt",
      "source_repo": "peterhinch/micropython-mqtt",
      "upstream_version": "master",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/Micropython%20Mqtt.py"
    },
    {
      "name": "NTP Time Sync",
      "filename": "NTP Time Sync.py",
      "version": [
        1,
        1,
        1
      ],
      "author": "JC`zic",
      "description": " This tool synchronizes the UTC date and time from an NTP server.\n                          You can choose the NTP server host to connect to and configure\n                          your timezone to display the correct local time.\n                      ",
      "category": "Network",
      "tags": [
        "network"
      ],
      "license": "MIT",
      "docs": "https://github.com/jczic",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/NTP%20Time%20Sync.py"
    },
    {
      "name": "OpenInverter UI",
      "filename": "OpenInverter UI.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "ScriptO Team",
      "description": "Full OpenInverter web interface with WebREPL communication.\n                         \n                         This ScriptO provides:\n                         • Full parameter display and editing\n                         • Real-time data visualization\n                         • CAN mapping management\n                         • Direct integration with OpenInverter via CAN bus\n                         \n                         The UI is served from /oi_ui/ directory and opens in a\n                         Studio modal. Communication happens via WebREPL using the\n                         existing OI_helpers functions - no REST API needed!\n                         \n                         Currently uses demo data from OI_helpers.py.\n                         For live hardware: enable CAN bus initialization below.\n                      ",
      "category": "UI Plugins",
      "tags": [
        "ui plugins"
      ],
      "license": "MIT",
      "docs": "https://github.com/jep-scriptomatic",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/OpenInverter%20UI.py"
    },
    {
      "name": "PWM & Lighting",
      "filename": "PWM & Lighting.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "JC`zic",
      "description": "Uses a PWM on a GPIO and varies its duty cycle to make a led flash smoothly from 0 to 3.3V.",
      "category": "Hardware",
      "tags": [
        "hardware"
      ],
      "license": "MIT",
      "docs": "https://github.com/jczic",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/PWM%20%26%20Lighting.py"
    },
    {
      "name": "PWM & Servo Motor",
      "filename": "PWM & Servo Motor.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "JC`zic",
      "description": " Uses a PWM on a GPIO and drives a servo motor by varying its duty cycle.\n                          Several options are available to configure the servo motor, such as pulse frequency, pulse width and rotation time.   \n                      ",
      "category": "Hardware",
      "tags": [
        "hardware"
      ],
      "license": "MIT",
      "docs": "https://github.com/jczic",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/PWM%20%26%20Servo%20Motor.py"
    },
    {
      "name": "Script Object template ",
      "filename": "ScriptOs - Template.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "John Smith",
      "description": " This template is a guide to developing Script Objects in MicroPython for your Scriptomator device.                          You just have a \"dict\" to place in your code file with the 2 commented lines above and below.                          You can create user inputs of various types (str, int, float, bool, list, dict) which are retrieved at runtime via the \"args\" class.\n                          Use a \"list\" type to propose a choice between all the GPIO pins of the ESP32.\n                          Also, use the \"dict\" type to propose a multiple choice via the \"items\" sub-tree.\n                          You will be able to write your test scripts very quickly!\n                      ",
      "category": "Templates",
      "tags": [
        "templates"
      ],
      "license": "MIT",
      "docs": "https://docs.micropython.org",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/ScriptOs%20-%20Template.py"
    },
    {
      "name": "Stop Button Test",
      "filename": "Stop Button Test.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "ScriptO Studio",
      "description": "Simple infinite counter to test the Stop button. Counts up forever until stopped.",
      "category": "Testing",
      "tags": [
        "testing"
      ],
      "license": "MIT",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/Stop%20Button%20Test.py"
    },
    {
      "name": "Test - Handler Direct",
      "filename": "Test - Handler Direct.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "ScriptO Team",
      "description": "Test httpserver.on() directly to diagnose routing.",
      "category": "Testing",
      "tags": [
        "testing"
      ],
      "license": "MIT",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/Test%20-%20Handler%20Direct.py"
    },
    {
      "name": "Test - Manual File Handler",
      "filename": "Test - Manual File Handler.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "ScriptO Team",
      "description": "Manually implement file serving with httpserver.on().",
      "category": "Testing",
      "tags": [
        "testing"
      ],
      "license": "MIT",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/Test%20-%20Manual%20File%20Handler.py"
    },
    {
      "name": "Queue Cleanup Test",
      "filename": "Test - Queue Cleanup.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "Jonathan E. Peace",
      "description": "Tests the queue cleanup refactor:\n                         - Static file serving with direct GIL\n                         - WebREPL file transfers with direct GIL\n                         - Concurrent operations\n                         - Memory usage verification\n                         \n                         This verifies that file I/O uses direct GIL acquisition\n                         instead of queuing, improving performance and simplicity.",
      "category": "Testing",
      "tags": [
        "testing"
      ],
      "license": "MIT",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/Test%20-%20Queue%20Cleanup.py"
    },
    {
      "name": "Test - VFS Diagnostics",
      "filename": "Test - VFS Diagnostics.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "ScriptO Team",
      "description": "Diagnose VFS mount points and filesystem structure.",
      "category": "Testing",
      "tags": [
        "testing"
      ],
      "license": "MIT",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/Test%20-%20VFS%20Diagnostics.py"
    },
    {
      "name": "Test - WebFiles Clean",
      "filename": "Test - WebFiles Clean.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "ScriptO Team",
      "description": "Clean test of webfiles with proper unregistration.",
      "category": "Testing",
      "tags": [
        "testing"
      ],
      "license": "MIT",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/Test%20-%20WebFiles%20Clean.py"
    },
    {
      "name": "Test - WebFiles Diagnostic",
      "filename": "Test - WebFiles Diagnostic.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "ScriptO Team",
      "description": "Check if webfiles handler gets called at all.",
      "category": "Testing",
      "tags": [
        "testing"
      ],
      "license": "MIT",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/Test%20-%20WebFiles%20Diagnostic.py"
    },
    {
      "name": "Test - WebFiles Gzip",
      "filename": "Test - WebFiles Gzip.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "ScriptO Team",
      "description": "Tests automatic gzip compression support in webfiles module.\n                         Creates both regular and .gz versions of test files.\n                         When client sends \"Accept-Encoding: gzip\", the .gz version is served automatically.\n                         This tests the new direct GIL file serving with mp_vfs_stat() gzip resolution.\n                      ",
      "category": "Tests/WebFiles",
      "tags": [
        "tests/webfiles"
      ],
      "license": "MIT",
      "docs": "https://github.com/scriptomatic",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/Test%20-%20WebFiles%20Gzip.py"
    },
    {
      "name": "Test - WebFiles Minimal",
      "filename": "Test - WebFiles Minimal.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "ScriptO Team",
      "description": "Minimal test - create one file and serve it.",
      "category": "Testing",
      "tags": [
        "testing"
      ],
      "license": "MIT",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/Test%20-%20WebFiles%20Minimal.py"
    },
    {
      "name": "Test - WebFiles Serving",
      "filename": "Test - WebFiles Serving.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "ScriptO Team",
      "description": "Test script to verify webfiles.serve() works correctly.\n                         \n                         This ScriptO:\n                         1. Creates /test_webfiles/ directory via Python VFS\n                         2. Creates a simple test.html file via Python VFS\n                         3. Finds correct ESP-IDF VFS mount point\n                         4. Serves it via webfiles.serve() (READ-ONLY)\n                         5. Opens it in Studio modal\n                         \n                         IMPORTANT: webfiles uses ESP-IDF VFS directly,\n                         while Python uses MicroPython VFS. The actual\n                         filesystem is usually mounted at /flash in ESP-IDF.\n                         \n                         webfiles should ONLY READ files, never write,\n                         to avoid corrupting MicroPython VFS metadata.\n                      ",
      "category": "Testing",
      "tags": [
        "testing"
      ],
      "license": "MIT",
      "docs": "https://github.com/jep-scriptomatic",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/Test%20-%20WebFiles%20Serving.py"
    },
    {
      "name": "Test - WebFiles Simple",
      "filename": "Test - WebFiles Simple.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "ScriptO Team",
      "description": "Super simple webfiles test - no modal, just browse manually.\n                         \n                         Creates /test_simple/hello.html and tries to serve it.\n                         Prints URLs to test in your browser.\n                      ",
      "category": "Testing",
      "tags": [
        "testing"
      ],
      "license": "MIT",
      "docs": "https://github.com/jep-scriptomatic",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/Test%20-%20WebFiles%20Simple.py"
    },
    {
      "name": "WebFiles Speed Test",
      "filename": "Test - WebFiles Speed Test.py",
      "version": [
        1,
        0
      ],
      "author": "ScriptOMatic",
      "description": "Measure file serving performance with various file sizes",
      "category": "Testing",
      "tags": [
        "testing"
      ],
      "license": "MIT",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/Test%20-%20WebFiles%20Speed%20Test.py"
    },
    {
      "name": "UART Test",
      "filename": "UART Test.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "JC`zic",
      "description": " Initializes an UART bus on two GPIO, sends or not a custom command and receives data from the bus.\n                          You can choose bus identifier, baud rate, bits per character, parity, stop bits and TX/RX GPIO.\n                      ",
      "category": "Communication",
      "tags": [
        "communication"
      ],
      "license": "MIT",
      "docs": "https://github.com/jczic",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/UART%20Test.py"
    },
    {
      "name": "UI Plugin - Hello World",
      "filename": "UI Plugin - Hello World.py",
      "version": [
        1,
        0,
        1
      ],
      "author": "ScriptO Team",
      "description": "Minimal demonstration of the ScriptO UI Plugin Architecture.\n                         \n                         This ScriptO:\n                         • Registers an HTTP route that serves a self-contained HTML page\n                         • Sends a command to Studio to open the UI in a modal\n                         • The UI is served directly from your ESP32 device\n                         \n                         This proves the end-to-end plugin flow where ScriptOs can provide \n                         their own web-based user interfaces without requiring any code changes \n                         in ScriptO Studio.\n                         \n                         The UI appears in an iframe modal and communicates directly with the device.\n                      ",
      "category": "UI Plugins",
      "tags": [
        "ui plugins"
      ],
      "license": "MIT",
      "docs": "https://github.com/jep-scriptomatic",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/UI%20Plugin%20-%20Hello%20World.py"
    },
    {
      "name": "Wi-Fi Scan",
      "filename": "Wi-Fi Scan.py",
      "version": [
        1,
        0,
        0
      ],
      "author": "JC`zic",
      "description": "Performs a detailed scan of the wireless access points.",
      "category": "Network",
      "tags": [
        "network"
      ],
      "license": "MIT",
      "docs": "https://github.com/jczic",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/ScriptOs/Wi-Fi%20Scan.py"
    }
  ],
  "apps": [
    {
      "name": "OpenInverter",
      "id": "openinverter",
      "filename": "OpenInverter.app.js",
      "version": [
        0,
        4,
        0
      ],
      "author": "JetPax",
      "description": "OpenInverter debug and configuration tool for motor control parameters, spot values, CAN mapping, and live plotting",
      "icon": "sliders",
      "menu": [
        {
          "id": "parameters",
          "label": "Parameters",
          "icon": "sliders"
        },
        {
          "id": "spotvalues",
          "label": "Spot Values",
          "icon": "activity"
        },
        {
          "id": "canmapping",
          "label": "CAN Mapping",
          "icon": "radio"
        },
        {
          "id": "commands",
          "label": "Commands",
          "icon": "zap"
        },
        {
          "id": "errors",
          "label": "Error Log",
          "icon": "alert-triangle"
        },
        {
          "id": "plot",
          "label": "Live Plot",
          "icon": "trending-up"
        }
      ],
      "styles": ".oi-compact-header { padding: 16px 20px !important; min-height: auto !important; display: flex; justify-content: space-between; align-items: center; } .oi-compact-header h2 { font-size: 18px !important; margin: 0 !important; } .oi-button-row { display: flex; flex-direction: row; gap: 8px; flex-wrap: wrap; align-items: center; } .oi-button-row .secondary-button, .oi-button-row .primary-button { padding: 6px 12px !important; font-size: 12px !important; font-weight: 600; text-transform: none; letter-spacing: normal; display: flex; align-items: center; gap: 6px; } .oi-button-row .secondary-button svg, .oi-button-row .primary-button svg { width: 14px; height: 14px; flex-shrink: 0; } .oi-plot-controls { display: flex; gap: 20px; align-items: center; } .oi-plot-controls .button { display: flex; flex-direction: column; align-items: center; } .oi-plot-controls .codicon { font-size: 20px; } .oi-parameters-container { padding: 20px; } .oi-category-section { margin-bottom: 32px; } .oi-category-title { font-size: 18px; font-weight: 600; color: var(--scheme-primary); margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid var(--scheme-primary); } .oi-parameters-table { border: 1px solid var(--border-color); border-radius: 4px; overflow: hidden; } .oi-table-header, .oi-table-row { display: grid; grid-template-columns: 1.5fr 1fr 0.8fr 1.2fr 0.8fr; gap: 12px; padding: 6px 16px; align-items: center; } .oi-table-header { background: var(--scheme-primary); color: white; font-weight: 600; font-size: 13px; text-transform: uppercase; letter-spacing: 0.5px; } .oi-table-row { border-bottom: 1px solid var(--border-color); transition: background 0.2s; padding: 3px 16px; } .oi-table-row:hover { background: var(--bg-tertiary); } .oi-table-row:last-child { border-bottom: none; } .oi-value-input, .oi-enum-select { width: 100%; padding: 6px 0px; border: 1px solid #34495e; border-radius: 4px; background: #2c3e50; color: #0fdb0f; font-size: 14px; font-family: 'Menlo', 'Monaco', 'Courier New', monospace; } .oi-value-input:focus, .oi-enum-select:focus { outline: none; border-color: var(--scheme-primary); box-shadow: 0 0 0 2px rgba(0, 129, 132, 0.2); } .oi-spotvalues-container { padding: 20px; } .oi-spotvalues-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 16px; } .oi-spotvalue-card { background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 8px; padding: 16px; transition: all 0.2s; } .oi-spotvalue-card:hover { border-color: var(--scheme-primary); box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); } .oi-spotvalue-name { font-weight: 600; color: var(--scheme-primary); font-size: 13px; margin-bottom: 8px; } .oi-spotvalue-value { font-size: 24px; font-weight: 700; font-family: 'Menlo', Monaco, 'Courier New', monospace; color: white; } .oi-plot-container { display: flex; height: 500px; max-height: calc(100vh - 260px); gap: 20px; padding: 20px; overflow: hidden; } .oi-plot-sidebar { width: 280px; flex-shrink: 0; border-right: 1px solid var(--border-color); padding-right: 20px; overflow-y: auto; } .oi-plot-section-title { font-size: 14px; font-weight: 600; color: var(--scheme-primary); margin: 16px 0 12px 0; text-transform: uppercase; letter-spacing: 0.5px; } .oi-plot-signal-list { display: flex; flex-direction: column; gap: 8px; margin-bottom: 24px; } .oi-plot-signal { padding: 8px; border-radius: 4px; transition: background 0.2s; } .oi-plot-signal:hover { background: var(--bg-tertiary); } .oi-plot-signal label { display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 13px; } .oi-plot-signal input[type=\"checkbox\"] { width: 16px; height: 16px; cursor: pointer; } .oi-plot-signal-name { font-weight: 600; color: var(--text-primary); } .oi-plot-signal-unit { color: var(--text-secondary); font-size: 12px; margin-left: auto; } .oi-plot-settings { display: flex; flex-direction: column; gap: 12px; } .oi-plot-settings label { display: flex; flex-direction: column; gap: 4px; font-size: 13px; color: var(--text-secondary); } .oi-plot-settings input[type=\"number\"] { padding: 6px 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-secondary); color: var(--text-primary); font-size: 13px; } .oi-plot-settings input[type=\"number\"]:focus { outline: none; border-color: var(--scheme-primary); box-shadow: 0 0 0 2px rgba(0, 129, 132, 0.2); } .oi-plot-chart-area { flex: 1; position: relative; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 8px; padding: 16px; min-height: 0; min-width: 0; display: flex; flex-direction: column; } .oi-plot-chart-area canvas { width: 100% !important; height: 100% !important; max-width: 100%; max-height: 100%; }",
      "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/Apps/OpenInverter/OpenInverter.app.js",
      "dependencies": [
        {
          "file": "lib/OI_helpers.py",
          "destination": "/lib/OI_helpers.py",
          "description": "OpenInverter parameter and CAN mapping helpers",
          "content": "\"\"\"\nOpenInverter Helper Functions\n==============================\n\nThis module contains helper functions for OpenInverter parameter management\nand CAN bus mapping. These functions are callable from the WebREPL client\nand automatically send their JSON responses directly to the connected client.\n\nClient-callable functions (auto-send to client):\n- getOiParams()           - Get list of parameters (isparam=True)\n- setParameter(args)      - Set a single parameter value\n- saveParameters()        - Save parameters to persistent storage\n- getParametersForDownload() - Get parameters for export/download\n- setParametersBatch(args) - Set multiple parameters at once\n- getSpotValues()         - Get list of spot values (isparam=False)\n- getPlotData(args)       - Get real-time values for plotting\n- mapCanSpotValue(args)   - Map a spot value to CAN bus\n- unmapCanSpotValue(args) - Remove CAN mapping from spot value\n- getCanMappingData()     - Get all parameters with CAN mapping info\n- getSysInfo()            - Get OpenInverter system info\n- actionButton(args)      - Handle action button press\n- termCmd(args)           - Handle terminal command\n\nGlobal Parameters Store:\n- parameters: Dictionary of all parameters and spot values\n  Structure: {\n    'name': {\n      'value': <number>,\n      'unit': <string>,\n      'isparam': <bool>,\n      'category': <string>,\n      # For parameters only:\n      'minimum': <number>,\n      'maximum': <number>,\n      'default': <number>,\n      'enums': {<int>: <string>, ...},  # Optional for enum parameters\n      # For CAN-mapped values:\n      'canId': <int>,\n      'canPosition': <int>,\n      'canBits': <int>,\n      'canGain': <float>,\n      'isTx': <bool>\n    }\n  }\n\"\"\"\n\nimport json\nimport time\n\n# Import webrepl to send responses directly to client\nfrom esp32 import webrepl\n\n# Try to import CAN and SDO modules (may not be available on all platforms)\ntry:\n    import CAN\n    from lib.canopen_sdo import SDOClient, fixed_to_float, float_to_fixed, param_id_to_sdo\n    from lib.canopen_sdo import SDOTimeoutError, SDOAbortError\n    CAN_AVAILABLE = True\nexcept ImportError:\n    print(\"[OI] Warning: CAN module not available, using demo data only\")\n    CAN_AVAILABLE = False\n\n# --- Global CAN and Device State ---\ncan_dev = None\nsdo_client = None\ndevice_connected = False\ndevice_node_id = 1\ndevice_bitrate = 500000\nparam_db_cache = None\nstreaming_active = False\n\n# --- Global Parameters/Spot Values Store (Demo Data or from device) ---\n# This will be replaced with actual device data when connected\nparameters = {\n    'udc': {\n        'value': 350.5, 'unit': 'V', 'isparam': False, 'category': 'Inputs',\n        'canId': 500, 'canPosition': 0, 'canBits': 16, 'canGain': 0.1, 'isTx': True\n    },\n    'fslipspnt': {\n        'value': 2.0, 'unit': 'Hz', 'isparam': True, 'category': 'Motor',\n        'minimum': 0, 'maximum': 10, 'default': 1.5\n    },\n    'opmode': {\n        'value': 1, 'unit': '', 'isparam': True, 'category': 'Control',\n        'enums': {0: 'Off', 1: 'Manual', 2: 'Auto'}, 'default': 0\n    },\n    'fout': {\n        'value': 50.1, 'unit': 'Hz', 'isparam': False, 'category': 'Outputs'\n    },\n    'id': {\n        'value': 10.0, 'unit': 'A', 'isparam': False, 'category': 'Outputs',\n        'canId': 501, 'canPosition': 0, 'canBits': 16, 'canGain': 1.0, 'isTx': False\n    },\n    'iq': {\n        'value': 25.0, 'unit': 'A', 'isparam': False, 'category': 'Outputs'\n    },\n    'tmpm': {\n        'value': 45, 'unit': 'C', 'isparam': False, 'category': 'Temps',\n        'canId': 500, 'canPosition': 16, 'canBits': 8, 'canGain': 1.0, 'isTx': True\n    },\n    'kp': {\n        'value': 100, 'unit': '', 'isparam': True, 'category': 'Control',\n        'minimum': 0, 'maximum': 1000, 'default': 150\n    },\n    'ki': {\n        'value': 50, 'unit': '', 'isparam': True, 'category': 'Control',\n        'minimum': 0, 'maximum': 500, 'default': 80\n    }\n}\n\n\ndef _send_response(cmd, arg):\n    \"\"\"Internal helper to send JSON response to WebREPL client\"\"\"\n    response = json.dumps({'CMD': cmd, 'ARG': arg})\n    webrepl.send(response)\n\n\ndef _send_error(message, cmd):\n    \"\"\"Internal helper to send error response\"\"\"\n    response = json.dumps({'CMD': cmd, 'ARG': {'error': message}})\n    webrepl.send(response)\n\n\ndef _send_success(message, cmd):\n    \"\"\"Internal helper to send success response\"\"\"\n    response = json.dumps({'CMD': cmd, 'ARG': {'success': True, 'message': message}})\n    webrepl.send(response)\n\n\n# ============================================================================\n# CAN Device Initialization and Management\n# ============================================================================\n\ndef initializeDevice(args=None):\n    \"\"\"\n    Initialize CAN bus and connect to OpenInverter device.\n    \n    Args (dict, optional):\n        node_id: CANopen node ID (default: 1)\n        bitrate: CAN bus bitrate (default: 500000)\n        tx_pin: TX GPIO pin (default: 5)\n        rx_pin: RX GPIO pin (default: 4)\n        mode: CAN mode (default: CAN.NORMAL)\n    \n    Returns:\n        Connection status and device info\n    \"\"\"\n    global can_dev, sdo_client, device_connected, device_node_id, device_bitrate\n    \n    if not CAN_AVAILABLE:\n        _send_error(\"CAN module not available on this platform\", 'INIT-DEVICE-ERROR')\n        return\n    \n    # Parse arguments\n    if args is None:\n        args = {}\n    \n    node_id = args.get('node_id', 1)\n    bitrate = args.get('bitrate', 500000)\n    tx_pin = args.get('tx_pin', 5)\n    rx_pin = args.get('rx_pin', 4)\n    mode = args.get('mode', CAN.NORMAL)\n    \n    try:\n        print(f\"[OI] Initializing CAN: node_id={node_id}, bitrate={bitrate}, tx={tx_pin}, rx={rx_pin}\")\n        \n        # Initialize CAN device\n        can_dev = CAN(0, extframe=False, tx=tx_pin, rx=rx_pin, mode=mode, bitrate=bitrate, auto_restart=True)\n        \n        # Create SDO client\n        sdo_client = SDOClient(can_dev, node_id=node_id, timeout=1.0)\n        \n        device_connected = True\n        device_node_id = node_id\n        device_bitrate = bitrate\n        \n        print(f\"[OI] CAN initialized successfully\")\n        \n        # Try to read a basic parameter to verify connection\n        try:\n            # Read uptime or another safe spot value to verify connection\n            # For now, just confirm initialization\n            _send_response('DEVICE-INITIALIZED', {\n                'success': True,\n                'node_id': node_id,\n                'bitrate': bitrate,\n                'connected': True\n            })\n        except Exception as e:\n            print(f\"[OI] Warning: Device connection test failed: {e}\")\n            _send_response('DEVICE-INITIALIZED', {\n                'success': True,\n                'node_id': node_id,\n                'bitrate': bitrate,\n                'connected': False,\n                'warning': 'CAN initialized but device not responding'\n            })\n            \n    except Exception as e:\n        print(f\"[OI] Error initializing CAN: {e}\")\n        device_connected = False\n        _send_error(f\"Failed to initialize CAN: {str(e)}\", 'INIT-DEVICE-ERROR')\n\n\ndef disconnectDevice():\n    \"\"\"\n    Disconnect from CAN bus and release resources.\n    \"\"\"\n    global can_dev, sdo_client, device_connected, streaming_active\n    \n    if streaming_active:\n        # Stop streaming first\n        stopLiveStreaming()\n    \n    device_connected = False\n    sdo_client = None\n    \n    # CAN device cleanup would go here if needed\n    # For now, just mark as disconnected\n    \n    _send_success(\"Device disconnected\", 'DEVICE-DISCONNECTED')\n\n\ndef getDeviceStatus():\n    \"\"\"\n    Get current device connection status.\n    \"\"\"\n    status = {\n        'connected': device_connected,\n        'can_available': CAN_AVAILABLE,\n        'node_id': device_node_id,\n        'bitrate': device_bitrate,\n        'streaming_active': streaming_active\n    }\n    \n    _send_response('DEVICE-STATUS', status)\n\n\ndef fetchParameterDatabase():\n    \"\"\"\n    Fetch parameter database from OpenInverter device.\n    \n    The parameter database is stored as a JSON string in the device\n    at SDO index 0x1021. This contains definitions for all parameters\n    and spot values with their units, ranges, categories, etc.\n    \n    Returns:\n        Dictionary of parameter definitions\n    \"\"\"\n    global param_db_cache, parameters\n    \n    if not device_connected or sdo_client is None:\n        _send_error(\"Device not connected\", 'FETCH-PARAM-DB-ERROR')\n        return\n    \n    try:\n        print(\"[OI] Fetching parameter database from device...\")\n        \n        # Parameter database is at SDO 0x1021, subindex 0\n        # It's stored as a large JSON string, so we need to read it in chunks\n        # For now, we'll use a simplified approach\n        \n        # Note: OpenInverter may store the DB differently, this is a placeholder\n        # The actual implementation would need to read the JSON database\n        # which might be multiple SDO objects or a file transfer\n        \n        # For now, return error as this needs device-specific implementation\n        _send_error(\"Parameter database fetching not yet implemented for real hardware\", 'FETCH-PARAM-DB-ERROR')\n        \n        # TODO: Implement actual DB fetching\n        # The openinverter-can-tool does this via:\n        # 1. Reading chunks of data from device\n        # 2. Assembling JSON string\n        # 3. Parsing to get parameter definitions\n        \n    except SDOTimeoutError as e:\n        print(f\"[OI] Timeout fetching parameter database: {e}\")\n        _send_error(str(e), 'FETCH-PARAM-DB-ERROR')\n    except SDOAbortError as e:\n        print(f\"[OI] SDO abort fetching parameter database: {e}\")\n        _send_error(str(e), 'FETCH-PARAM-DB-ERROR')\n    except Exception as e:\n        print(f\"[OI] Error fetching parameter database: {e}\")\n        _send_error(str(e), 'FETCH-PARAM-DB-ERROR')\n\n\ndef loadParameterDatabase(json_db):\n    \"\"\"\n    Load parameter database from JSON structure.\n    \n    Args:\n        json_db: Dictionary containing parameter definitions\n    \n    Converts OpenInverter parameter database format to our internal format.\n    \"\"\"\n    global parameters, param_db_cache\n    \n    try:\n        parameters = {}\n        \n        for param_name, param_def in json_db.items():\n            # Convert OpenInverter format to our format\n            param = {\n                'unit': param_def.get('unit', ''),\n                'isparam': param_def.get('isparam', False),\n                'category': param_def.get('category', 'Uncategorized'),\n                'id': param_def.get('id')\n            }\n            \n            # For parameters, add min/max/default\n            if param['isparam']:\n                param['minimum'] = param_def.get('minimum', 0)\n                param['maximum'] = param_def.get('maximum', 0)\n                param['default'] = param_def.get('default', 0)\n            \n            # Parse enumerations from unit string if present\n            # Format: \"0=Off 1=On 2=Auto\"\n            unit = param_def.get('unit', '')\n            if '=' in unit:\n                enums = {}\n                for part in unit.split():\n                    if '=' in part:\n                        try:\n                            val, name = part.split('=', 1)\n                            enums[int(val)] = name\n                        except:\n                            pass\n                if enums:\n                    param['enums'] = enums\n            \n            parameters[param_name] = param\n        \n        param_db_cache = json_db\n        print(f\"[OI] Loaded {len(parameters)} parameters from database\")\n        _send_success(f\"Loaded {len(parameters)} parameters\", 'PARAM-DB-LOADED')\n        \n    except Exception as e:\n        print(f\"[OI] Error loading parameter database: {e}\")\n        _send_error(str(e), 'PARAM-DB-LOAD-ERROR')\n\n\ndef getOiParams():\n    \"\"\"\n    Get list of all parameters (isparam=True).\n    Sends the result directly to the WebREPL client as JSON.\n    \n    If connected to real device, reads current values via SDO.\n    Otherwise, returns demo data.\n    \"\"\"\n    param_list = {}\n    \n    # If connected to device, read actual values\n    if device_connected and sdo_client and CAN_AVAILABLE:\n        try:\n            for key, item in parameters.items():\n                if item.get('isparam') == True:\n                    # Read current value from device\n                    param_id = item.get('id')\n                    if param_id is not None:\n                        try:\n                            index, subindex = param_id_to_sdo(param_id)\n                            raw_value = sdo_client.read(index, subindex)\n                            item['value'] = fixed_to_float(raw_value)\n                        except (SDOTimeoutError, SDOAbortError) as e:\n                            print(f\"[OI] Warning: Failed to read {key}: {e}\")\n                            # Keep existing value\n                    \n                    param_list[key] = item\n        except Exception as e:\n            print(f\"[OI] Error reading parameters: {e}\")\n            # Fall back to cached values\n            for key, item in parameters.items():\n                if item.get('isparam') == True:\n                    param_list[key] = item\n    else:\n        # Use demo/cached data\n        for key, item in parameters.items():\n            if item.get('isparam') == True:\n                param_list[key] = item\n    \n    _send_response('PARAMETERS-LIST', param_list)\n\n\ndef setParameter(args):\n    \"\"\"\n    Set a single parameter value.\n    \n    Args (dict):\n        NAME: Parameter name\n        VALUE: New value\n    \n    Sends the updated parameter or error to WebREPL client.\n    \"\"\"\n    param_name = args.get('NAME')\n    param_value = args.get('VALUE')\n    \n    if param_name is None or param_value is None:\n        _send_error(\"Missing NAME or VALUE for SET-PARAMETER\", 'SET-PARAMETER-ERROR')\n        return\n    \n    if param_name in parameters and parameters[param_name].get('isparam') == True:\n        # Validate value against min/max if present\n        param_def = parameters[param_name]\n        \n        if 'minimum' in param_def and param_value < param_def['minimum']:\n            _send_error(f\"Value {param_value} below minimum {param_def['minimum']}\", 'SET-PARAMETER-ERROR')\n            return\n        \n        if 'maximum' in param_def and param_value > param_def['maximum']:\n            _send_error(f\"Value {param_value} above maximum {param_def['maximum']}\", 'SET-PARAMETER-ERROR')\n            return\n        \n        # Validate enum if present\n        if 'enums' in param_def and param_value not in param_def['enums']:\n            _send_error(f\"Value {param_value} not in valid enums\", 'SET-PARAMETER-ERROR')\n            return\n        \n        print(f\"[OI] Setting parameter: {param_name} to {param_value}\")\n        \n        # If connected to device, write via SDO\n        if device_connected and sdo_client and CAN_AVAILABLE:\n            param_id = param_def.get('id')\n            if param_id is not None:\n                try:\n                    index, subindex = param_id_to_sdo(param_id)\n                    fixed_value = float_to_fixed(param_value)\n                    sdo_client.write(index, subindex, fixed_value)\n                    print(f\"[OI] Successfully wrote {param_name} to device\")\n                except SDOTimeoutError as e:\n                    _send_error(f\"Timeout writing parameter: {str(e)}\", 'SET-PARAMETER-ERROR')\n                    return\n                except SDOAbortError as e:\n                    _send_error(f\"Device rejected parameter: {str(e)}\", 'SET-PARAMETER-ERROR')\n                    return\n                except Exception as e:\n                    _send_error(f\"Error writing parameter: {str(e)}\", 'SET-PARAMETER-ERROR')\n                    return\n        \n        # Update cached value\n        parameters[param_name]['value'] = param_value\n        \n        updated_param = {param_name: parameters[param_name]}\n        _send_response('PARAMETER-UPDATED', updated_param)\n    else:\n        _send_error(f\"Invalid or non-parameter name: {param_name}\", 'SET-PARAMETER-ERROR')\n\n\ndef saveParameters():\n    \"\"\"\n    Save parameters to persistent storage.\n    \n    TODO: Implement actual saving logic (e.g., to NVS, JSON file on flash)\n    For now, just acknowledges the save request.\n    \"\"\"\n    print(\"[OI] STUB: Handling SAVE-PARAMETERS\")\n    # TODO: Implement actual saving logic\n    # Example:\n    # import json\n    # with open('/flash/oi_params.json', 'w') as f:\n    #     json.dump({k: v for k, v in parameters.items() if v.get('isparam')}, f)\n    \n    _send_success(\"Parameters saved (stub).\", 'PARAMETERS-SAVED')\n\n\ndef getParametersForDownload():\n    \"\"\"\n    Get all parameters for export/download.\n    Same as getOiParams() but with different command name.\n    \"\"\"\n    param_list = {}\n    \n    for key, item in parameters.items():\n        if item.get('isparam') == True:\n            param_list[key] = item\n    \n    _send_response('PARAMETERS-DOWNLOAD-LIST', param_list)\n\n\ndef setParametersBatch(params_to_set):\n    \"\"\"\n    Set multiple parameters at once.\n    \n    Args (dict):\n        {param_name: value, ...}\n    \n    Sends batch result with success status and details for each parameter.\n    \"\"\"\n    update_results = {}\n    success = True\n    \n    if not isinstance(params_to_set, dict):\n        _send_error(\"Invalid argument format for batch set\", 'SET-PARAMETERS-BATCH-ERROR')\n        return\n    \n    for name, value in params_to_set.items():\n        if name in parameters and parameters[name].get('isparam') == True:\n            param_def = parameters[name]\n            \n            # Validate value\n            if 'minimum' in param_def and value < param_def['minimum']:\n                update_results[name] = {'status': 'error', 'message': f'Below minimum {param_def[\"minimum\"]}'}\n                success = False\n                continue\n            \n            if 'maximum' in param_def and value > param_def['maximum']:\n                update_results[name] = {'status': 'error', 'message': f'Above maximum {param_def[\"maximum\"]}'}\n                success = False\n                continue\n            \n            if 'enums' in param_def and value not in param_def['enums']:\n                update_results[name] = {'status': 'error', 'message': 'Invalid enum value'}\n                success = False\n                continue\n            \n            parameters[name]['value'] = value\n            update_results[name] = {'status': 'success', 'value': value}\n        else:\n            update_results[name] = {'status': 'error', 'message': 'Invalid or non-parameter'}\n            success = False\n    \n    _send_response('PARAMETERS-BATCH-RESULT', {'success': success, 'details': update_results})\n\n\ndef getSpotValues():\n    \"\"\"\n    Get list of all spot values (isparam=False).\n    Sends the result directly to the WebREPL client as JSON.\n    \n    If connected to real device, reads current values via SDO.\n    Otherwise, returns demo data.\n    \"\"\"\n    spot_list = {}\n    \n    # If connected to device, read actual values\n    if device_connected and sdo_client and CAN_AVAILABLE:\n        try:\n            for key, item in parameters.items():\n                if item.get('isparam') != True:\n                    # Read current value from device\n                    param_id = item.get('id')\n                    if param_id is not None:\n                        try:\n                            index, subindex = param_id_to_sdo(param_id)\n                            raw_value = sdo_client.read(index, subindex)\n                            item['value'] = fixed_to_float(raw_value)\n                        except (SDOTimeoutError, SDOAbortError) as e:\n                            print(f\"[OI] Warning: Failed to read {key}: {e}\")\n                            # Keep existing value\n                    \n                    spot_list[key] = item\n        except Exception as e:\n            print(f\"[OI] Error reading spot values: {e}\")\n            # Fall back to cached values\n            for key, item in parameters.items():\n                if item.get('isparam') != True:\n                    spot_list[key] = item\n    else:\n        # Use demo/cached data\n        for key, item in parameters.items():\n            if item.get('isparam') != True:\n                spot_list[key] = item\n    \n    _send_response('SPOT-VALUES-LIST', spot_list)\n\n\ndef getPlotData(args):\n    \"\"\"\n    Get real-time values for plotting.\n    \n    Args (list):\n        List of variable names to retrieve\n    \n    Returns values with timestamp for plotting.\n    \n    Note: This only works in Configuration Mode, not during streaming.\n    For high-speed plotting, use C streaming mode instead.\n    \"\"\"\n    # Note: Avoid print() here as it interferes with JSON response in WebREPL\n    \n    if streaming_active:\n        # Can't read via SDO while streaming\n        _send_error(\"Cannot read plot data in streaming mode\", 'PLOT-DATA-ERROR')\n        return\n    \n    response_values = {}\n    current_time = int(time.time())  # Unix timestamp\n    \n    if isinstance(args, list) and len(args) > 0:\n        # If connected to device, read fresh values\n        if device_connected and sdo_client and CAN_AVAILABLE:\n            for var_name in args:\n                if var_name in parameters:\n                    item = parameters[var_name]\n                    param_id = item.get('id')\n                    \n                    if param_id is not None:\n                        try:\n                            index, subindex = param_id_to_sdo(param_id)\n                            raw_value = sdo_client.read(index, subindex)\n                            value = fixed_to_float(raw_value)\n                            \n                            # Update cached value\n                            item['value'] = value\n                            response_values[var_name] = value\n                        except (SDOTimeoutError, SDOAbortError):\n                            # Use cached value on error\n                            value = item.get('value')\n                            if isinstance(value, (int, float)):\n                                response_values[var_name] = value\n                    else:\n                        # No param ID, use cached value\n                        value = item.get('value')\n                        if isinstance(value, (int, float)):\n                            response_values[var_name] = value\n        else:\n            # Use demo/cached data\n            for var_name in args:\n                if var_name in parameters:\n                    item = parameters[var_name]\n                    value = item['value']\n                    \n                    # Make sure it's a number that can be plotted\n                    if isinstance(value, (int, float)):\n                        response_values[var_name] = value\n        \n        # Construct the response payload\n        response_payload = {\n            'ts': current_time,\n            'values': response_values\n        }\n        \n        _send_response('PLOT-DATA-UPDATE', response_payload)\n\n\n# ============================================================================\n# CAN Mapping Functions\n# ============================================================================\n\ndef getCanMap(args=None):\n    \"\"\"\n    Get CAN mappings from device (TX or RX).\n    \n    Args (dict, optional):\n        direction: 'tx' or 'rx' (default: both)\n    \n    CAN mapping uses SDO indexes:\n    - TX map list: 0x3000 + n\n    - RX map list: 0x3100 + n\n    \"\"\"\n    if not device_connected or sdo_client is None:\n        _send_error(\"Device not connected\", 'CAN-MAP-ERROR')\n        return\n    \n    direction = args.get('direction', 'both') if args else 'both'\n    \n    try:\n        mappings = {'tx': [], 'rx': []}\n        \n        if direction in ['tx', 'both']:\n            # Read TX mappings starting at 0x3000\n            base_index = 0x3000\n            msg_index = 0\n            while msg_index < 255:  # Max messages\n                try:\n                    # Read CAN ID at subindex 0\n                    can_id = sdo_client.read(base_index + msg_index, 0)\n                    if can_id == 0:\n                        break  # No more messages\n                    \n                    # Extract extended frame flag (bit 31)\n                    is_extended = (can_id & 0x80000000) != 0\n                    can_id = can_id & 0x1FFFFFFF  # Mask out flag bit\n                    \n                    message = {\n                        'canId': can_id,\n                        'isExtended': is_extended,\n                        'params': []\n                    }\n                    \n                    # Read parameter mappings (subindex 1, 3, 5, ...)\n                    param_index = 1\n                    while param_index < 255:\n                        try:\n                            # Read param ID, position, length\n                            mapping_data = sdo_client.read(base_index + msg_index, param_index)\n                            if mapping_data == 0:\n                                break  # No more params\n                            \n                            param_id = mapping_data & 0xFFFF\n                            position = (mapping_data >> 16) & 0xFF\n                            length = (mapping_data >> 24) & 0xFF\n                            # Convert to signed if negative\n                            if length >= 128:\n                                length = length - 256\n                            \n                            # Read gain and offset (next subindex)\n                            gain_offset = sdo_client.read(base_index + msg_index, param_index + 1)\n                            gain = (gain_offset & 0xFFFFFF) / 1000.0  # 24-bit fixed point\n                            offset = (gain_offset >> 24) & 0xFF\n                            if offset >= 128:\n                                offset = offset - 256\n                            \n                            message['params'].append({\n                                'paramId': param_id,\n                                'position': position,\n                                'length': length,\n                                'gain': gain,\n                                'offset': offset\n                            })\n                            \n                            param_index += 2  # Skip to next param\n                        except (SDOTimeoutError, SDOAbortError):\n                            break\n                    \n                    if message['params']:  # Only add if has params\n                        mappings['tx'].append(message)\n                    \n                    msg_index += 1\n                except (SDOTimeoutError, SDOAbortError):\n                    break\n        \n        if direction in ['rx', 'both']:\n            # Read RX mappings starting at 0x3100\n            base_index = 0x3100\n            msg_index = 0\n            while msg_index < 255:\n                try:\n                    can_id = sdo_client.read(base_index + msg_index, 0)\n                    if can_id == 0:\n                        break\n                    \n                    is_extended = (can_id & 0x80000000) != 0\n                    can_id = can_id & 0x1FFFFFFF\n                    \n                    message = {\n                        'canId': can_id,\n                        'isExtended': is_extended,\n                        'params': []\n                    }\n                    \n                    param_index = 1\n                    while param_index < 255:\n                        try:\n                            mapping_data = sdo_client.read(base_index + msg_index, param_index)\n                            if mapping_data == 0:\n                                break\n                            \n                            param_id = mapping_data & 0xFFFF\n                            position = (mapping_data >> 16) & 0xFF\n                            length = (mapping_data >> 24) & 0xFF\n                            if length >= 128:\n                                length = length - 256\n                            \n                            gain_offset = sdo_client.read(base_index + msg_index, param_index + 1)\n                            gain = (gain_offset & 0xFFFFFF) / 1000.0\n                            offset = (gain_offset >> 24) & 0xFF\n                            if offset >= 128:\n                                offset = 256\n                            \n                            message['params'].append({\n                                'paramId': param_id,\n                                'position': position,\n                                'length': length,\n                                'gain': gain,\n                                'offset': offset\n                            })\n                            \n                            param_index += 2\n                        except (SDOTimeoutError, SDOAbortError):\n                            break\n                    \n                    if message['params']:\n                        mappings['rx'].append(message)\n                    \n                    msg_index += 1\n                except (SDOTimeoutError, SDOAbortError):\n                    break\n        \n        _send_response('CAN-MAP-LIST', mappings)\n        \n    except Exception as e:\n        print(f\"[OI] Error reading CAN mappings: {e}\")\n        _send_error(str(e), 'CAN-MAP-ERROR')\n\n\ndef addCanMapping(args):\n    \"\"\"\n    Add a CAN mapping entry.\n    \n    Args (dict):\n        can_id: CAN message ID\n        param_name: Parameter/spot value name\n        position: Bit position in CAN message\n        length: Number of bits (negative for big-endian)\n        gain: Scaling factor\n        offset: Offset value\n        is_tx: True for transmit, False for receive\n        is_extended: True for 29-bit extended frame\n    \"\"\"\n    if not device_connected or sdo_client is None:\n        _send_error(\"Device not connected\", 'CAN-MAP-ADD-ERROR')\n        return\n    \n    can_id = args.get('can_id')\n    param_name = args.get('param_name')\n    position = args.get('position', 0)\n    length = args.get('length', 16)\n    gain = args.get('gain', 1.0)\n    offset = args.get('offset', 0)\n    is_tx = args.get('is_tx', True)\n    is_extended = args.get('is_extended', False)\n    \n    if can_id is None or param_name is None:\n        _send_error(\"Missing can_id or param_name\", 'CAN-MAP-ADD-ERROR')\n        return\n    \n    # Get param ID from name\n    if param_name not in parameters:\n        _send_error(f\"Parameter {param_name} not found\", 'CAN-MAP-ADD-ERROR')\n        return\n    \n    param_id = parameters[param_name].get('id')\n    if param_id is None:\n        _send_error(f\"Parameter {param_name} has no ID\", 'CAN-MAP-ADD-ERROR')\n        return\n    \n    try:\n        # Use appropriate SDO index for TX (0x3200) or RX (0x3300)\n        base_index = 0x3200 if is_tx else 0x3300\n        \n        # Write CAN ID with extended frame flag if needed\n        can_id_value = can_id | (0x80000000 if is_extended else 0)\n        sdo_client.write(base_index, 0, can_id_value)\n        \n        # Write param ID, position, length\n        mapping_data = param_id | (position << 16) | ((length & 0xFF) << 24)\n        sdo_client.write(base_index, 1, mapping_data)\n        \n        # Write gain and offset\n        gain_fixed = int(gain * 1000) & 0xFFFFFF  # 24-bit fixed point\n        gain_offset_value = gain_fixed | ((offset & 0xFF) << 24)\n        sdo_client.write(base_index, 2, gain_offset_value)\n        \n        print(f\"[OI] Added CAN mapping: {param_name} to CAN ID {can_id}\")\n        _send_success(f\"Mapping added successfully\", 'CAN-MAP-ADDED')\n        \n    except (SDOTimeoutError, SDOAbortError) as e:\n        _send_error(str(e), 'CAN-MAP-ADD-ERROR')\n    except Exception as e:\n        _send_error(str(e), 'CAN-MAP-ADD-ERROR')\n\n\ndef removeCanMapping(args):\n    \"\"\"\n    Remove a CAN mapping entry.\n    \n    Args (dict):\n        direction: 'tx' or 'rx'\n        msg_index: Message index\n        param_index: Parameter index within message\n    \"\"\"\n    if not device_connected or sdo_client is None:\n        _send_error(\"Device not connected\", 'CAN-MAP-REMOVE-ERROR')\n        return\n    \n    direction = args.get('direction')\n    msg_index = args.get('msg_index')\n    param_index = args.get('param_index')\n    \n    if direction is None or msg_index is None or param_index is None:\n        _send_error(\"Missing direction, msg_index, or param_index\", 'CAN-MAP-REMOVE-ERROR')\n        return\n    \n    try:\n        base_index = 0x3000 if direction == 'tx' else 0x3100\n        target_index = base_index + msg_index\n        # Write 0 to the parameter subindex to remove it\n        # Device will automatically shift remaining params\n        target_subindex = 1 + (param_index * 2)\n        sdo_client.write(target_index, target_subindex, 0)\n        \n        _send_success(\"Mapping removed successfully\", 'CAN-MAP-REMOVED')\n        \n    except (SDOTimeoutError, SDOAbortError) as e:\n        _send_error(str(e), 'CAN-MAP-REMOVE-ERROR')\n    except Exception as e:\n        _send_error(str(e), 'CAN-MAP-REMOVE-ERROR')\n\n\ndef clearCanMap(args):\n    \"\"\"\n    Clear all CAN mappings for a direction.\n    \n    Args (dict):\n        direction: 'tx', 'rx', or 'all'\n    \"\"\"\n    if not device_connected or sdo_client is None:\n        _send_error(\"Device not connected\", 'CAN-MAP-CLEAR-ERROR')\n        return\n    \n    direction = args.get('direction', 'all')\n    \n    try:\n        # Repeatedly remove first entry until none remain\n        if direction in ['tx', 'all']:\n            base_index = 0x3000\n            while True:\n                try:\n                    # Try to remove first param of first message\n                    sdo_client.write(base_index, 1, 0)\n                except SDOAbortError:\n                    break  # No more mappings\n        \n        if direction in ['rx', 'all']:\n            base_index = 0x3100\n            while True:\n                try:\n                    sdo_client.write(base_index, 1, 0)\n                except SDOAbortError:\n                    break\n        \n        _send_success(f\"{direction} mappings cleared\", 'CAN-MAP-CLEARED')\n        \n    except Exception as e:\n        _send_error(str(e), 'CAN-MAP-CLEAR-ERROR')\n\n\ndef exportCanMapJson():\n    \"\"\"\n    Export CAN mappings as JSON for download.\n    \"\"\"\n    if not device_connected or sdo_client is None:\n        _send_error(\"Device not connected\", 'CAN-MAP-EXPORT-ERROR')\n        return\n    \n    # Use getCanMap to read mappings, then format for export\n    try:\n        # This is a simplified version - real implementation would\n        # call internal mapping read logic\n        _send_error(\"Export not yet implemented\", 'CAN-MAP-EXPORT-ERROR')\n    except Exception as e:\n        _send_error(str(e), 'CAN-MAP-EXPORT-ERROR')\n\n\ndef importCanMapJson(args):\n    \"\"\"\n    Import CAN mappings from JSON.\n    \n    Args (dict):\n        mappings: JSON structure with TX/RX mappings\n        clear_existing: Whether to clear existing mappings first\n    \"\"\"\n    if not device_connected or sdo_client is None:\n        _send_error(\"Device not connected\", 'CAN-MAP-IMPORT-ERROR')\n        return\n    \n    _send_error(\"Import not yet implemented\", 'CAN-MAP-IMPORT-ERROR')\n\n\n# Legacy functions - kept for backwards compatibility but deprecated\ndef mapCanSpotValue(args):\n    \"\"\"DEPRECATED: Use addCanMapping instead\"\"\"\n    print(\"[OI] Warning: mapCanSpotValue is deprecated, use addCanMapping\")\n    addCanMapping(args)\n\n\ndef unmapCanSpotValue(args):\n    \"\"\"DEPRECATED: Use removeCanMapping instead\"\"\"\n    print(\"[OI] Warning: unmapCanSpotValue is deprecated, use removeCanMapping\")\n    removeCanMapping(args)\n\n\ndef getCanMappingData():\n    \"\"\"DEPRECATED: Use getCanMap instead\"\"\"\n    print(\"[OI] Warning: getCanMappingData is deprecated, use getCanMap\")\n    getCanMap()\n\n\n# ============================================================================\n# Device Commands\n# ============================================================================\n\ndef deviceSave():\n    \"\"\"\n    Save parameters and CAN mappings to device flash.\n    \n    Commands use SDO index 0x3004.\n    \"\"\"\n    if not device_connected or sdo_client is None:\n        _send_error(\"Device not connected\", 'DEVICE-SAVE-ERROR')\n        return\n    \n    try:\n        # Send save command (subindex 1)\n        sdo_client.write(0x3004, 1, 0)\n        print(\"[OI] Sent save command to device\")\n        _send_success(\"Parameters saved to flash\", 'DEVICE-SAVED')\n    except (SDOTimeoutError, SDOAbortError) as e:\n        _send_error(str(e), 'DEVICE-SAVE-ERROR')\n    except Exception as e:\n        _send_error(str(e), 'DEVICE-SAVE-ERROR')\n\n\ndef deviceLoad():\n    \"\"\"\n    Load parameters and CAN mappings from device flash.\n    \"\"\"\n    if not device_connected or sdo_client is None:\n        _send_error(\"Device not connected\", 'DEVICE-LOAD-ERROR')\n        return\n    \n    try:\n        # Send load command (subindex 2)\n        sdo_client.write(0x3004, 2, 0)\n        print(\"[OI] Sent load command to device\")\n        _send_success(\"Parameters loaded from flash\", 'DEVICE-LOADED')\n    except (SDOTimeoutError, SDOAbortError) as e:\n        _send_error(str(e), 'DEVICE-LOAD-ERROR')\n    except Exception as e:\n        _send_error(str(e), 'DEVICE-LOAD-ERROR')\n\n\ndef deviceReset():\n    \"\"\"\n    Reset/reboot the device.\n    \"\"\"\n    if not device_connected or sdo_client is None:\n        _send_error(\"Device not connected\", 'DEVICE-RESET-ERROR')\n        return\n    \n    try:\n        # Send reset command (subindex 3)\n        sdo_client.write(0x3004, 3, 0)\n        print(\"[OI] Sent reset command to device\")\n        _send_success(\"Device reset initiated\", 'DEVICE-RESET')\n    except (SDOTimeoutError, SDOAbortError) as e:\n        _send_error(str(e), 'DEVICE-RESET-ERROR')\n    except Exception as e:\n        _send_error(str(e), 'DEVICE-RESET-ERROR')\n\n\ndef deviceLoadDefaults():\n    \"\"\"\n    Load default parameters (factory reset).\n    \"\"\"\n    if not device_connected or sdo_client is None:\n        _send_error(\"Device not connected\", 'DEVICE-DEFAULTS-ERROR')\n        return\n    \n    try:\n        # Send load defaults command (subindex 4)\n        sdo_client.write(0x3004, 4, 0)\n        print(\"[OI] Sent load defaults command to device\")\n        _send_success(\"Default parameters loaded\", 'DEVICE-DEFAULTS-LOADED')\n    except (SDOTimeoutError, SDOAbortError) as e:\n        _send_error(str(e), 'DEVICE-DEFAULTS-ERROR')\n    except Exception as e:\n        _send_error(str(e), 'DEVICE-DEFAULTS-ERROR')\n\n\ndef deviceStart(args=None):\n    \"\"\"\n    Start device operation in specified mode.\n    \n    Args (dict, optional):\n        mode: Operating mode (0=Normal, 1=Manual, 2=Boost, 3=Buck, 4=Sine, 5=ACHeat)\n    \"\"\"\n    if not device_connected or sdo_client is None:\n        _send_error(\"Device not connected\", 'DEVICE-START-ERROR')\n        return\n    \n    mode = args.get('mode', 0) if args else 0\n    \n    try:\n        # Send start command (subindex 5) with mode\n        sdo_client.write(0x3004, 5, mode)\n        mode_names = {0: 'Normal', 1: 'Manual', 2: 'Boost', 3: 'Buck', 4: 'Sine', 5: 'ACHeat'}\n        mode_name = mode_names.get(mode, f'Mode {mode}')\n        print(f\"[OI] Sent start command to device (mode: {mode_name})\")\n        _send_success(f\"Device started in {mode_name} mode\", 'DEVICE-STARTED')\n    except (SDOTimeoutError, SDOAbortError) as e:\n        _send_error(str(e), 'DEVICE-START-ERROR')\n    except Exception as e:\n        _send_error(str(e), 'DEVICE-START-ERROR')\n\n\ndef deviceStop():\n    \"\"\"\n    Stop device operation.\n    \"\"\"\n    if not device_connected or sdo_client is None:\n        _send_error(\"Device not connected\", 'DEVICE-STOP-ERROR')\n        return\n    \n    try:\n        # Send stop command (subindex 6)\n        sdo_client.write(0x3004, 6, 0)\n        print(\"[OI] Sent stop command to device\")\n        _send_success(\"Device stopped\", 'DEVICE-STOPPED')\n    except (SDOTimeoutError, SDOAbortError) as e:\n        _send_error(str(e), 'DEVICE-STOP-ERROR')\n    except Exception as e:\n        _send_error(str(e), 'DEVICE-STOP-ERROR')\n\n\n# ============================================================================\n# Device Info and Error Log\n# ============================================================================\n\ndef getSerialNumber():\n    \"\"\"\n    Read device serial number.\n    \n    Serial number is at SDO 0x5000, subindex 0-2 (3 parts).\n    \"\"\"\n    if not device_connected or sdo_client is None:\n        _send_error(\"Device not connected\", 'SERIAL-NUMBER-ERROR')\n        return\n    \n    try:\n        # Read 3 parts of serial number\n        serial_parts = []\n        for i in range(3):\n            part = sdo_client.read(0x5000, i)\n            # Format as hex string\n            serial_parts.append(f\"{part:08X}\")\n        \n        serial_number = \":\".join(serial_parts)\n        print(f\"[OI] Device serial number: {serial_number}\")\n        _send_response('SERIAL-NUMBER', {'serialNumber': serial_number})\n    except (SDOTimeoutError, SDOAbortError) as e:\n        _send_error(str(e), 'SERIAL-NUMBER-ERROR')\n    except Exception as e:\n        _send_error(str(e), 'SERIAL-NUMBER-ERROR')\n\n\ndef getDeviceInfo():\n    \"\"\"\n    Get device information (firmware version, uptime, etc).\n    \"\"\"\n    if not device_connected or sdo_client is None:\n        _send_error(\"Device not connected\", 'DEVICE-INFO-ERROR')\n        return\n    \n    try:\n        info = {\n            'connected': True,\n            'node_id': device_node_id,\n            'bitrate': device_bitrate\n        }\n        \n        # Try to read uptime (common spot value)\n        try:\n            if 'uptime' in parameters:\n                param_id = parameters['uptime'].get('id')\n                if param_id:\n                    index, subindex = param_id_to_sdo(param_id)\n                    raw_value = sdo_client.read(index, subindex)\n                    info['uptime'] = fixed_to_float(raw_value)\n        except:\n            pass\n        \n        _send_response('DEVICE-INFO', info)\n    except Exception as e:\n        _send_error(str(e), 'DEVICE-INFO-ERROR')\n\n\ndef getErrorLog():\n    \"\"\"\n    Get error log from device.\n    \n    Error times at SDO 0x2001, error codes at 0x2002.\n    \"\"\"\n    if not device_connected or sdo_client is None:\n        _send_error(\"Device not connected\", 'ERROR-LOG-ERROR')\n        return\n    \n    try:\n        errors = []\n        \n        # Read error log (up to 255 entries)\n        for i in range(255):\n            try:\n                # Read error time\n                error_time = sdo_client.read(0x2001, i)\n                if error_time == 0:\n                    break  # No more errors\n                \n                # Read error code\n                error_code = sdo_client.read(0x2002, i)\n                \n                errors.append({\n                    'timestamp': error_time,\n                    'code': error_code,\n                    'description': f\"Error code {error_code}\"\n                })\n            except (SDOTimeoutError, SDOAbortError):\n                break\n        \n        print(f\"[OI] Retrieved {len(errors)} error entries\")\n        _send_response('ERROR-LOG', {'errors': errors})\n    except Exception as e:\n        _send_error(str(e), 'ERROR-LOG-ERROR')\n\n\n# ============================================================================\n# Streaming Mode Control\n# ============================================================================\n\ndef startLiveStreaming(can_ids):\n    \"\"\"\n    Start C streaming mode for high-speed data acquisition.\n    \n    Args:\n        can_ids: List of CAN IDs to stream\n    \n    NOTE: Cannot do SDO operations while streaming!\n    \"\"\"\n    global streaming_active\n    \n    if not CAN_AVAILABLE or can_dev is None:\n        _send_error(\"CAN not available\", 'STREAMING-START-ERROR')\n        return\n    \n    try:\n        # Configure hardware filters\n        can_dev.set_filter(can_ids)\n        \n        # Start streaming\n        can_dev.stream_start()\n        \n        streaming_active = True\n        print(f\"[OI] Started streaming for CAN IDs: {can_ids}\")\n        _send_success(\"Streaming started\", 'STREAMING-STARTED')\n    except Exception as e:\n        _send_error(str(e), 'STREAMING-START-ERROR')\n\n\ndef stopLiveStreaming():\n    \"\"\"\n    Stop C streaming mode and return to configuration mode.\n    \"\"\"\n    global streaming_active\n    \n    if not CAN_AVAILABLE or can_dev is None:\n        _send_error(\"CAN not available\", 'STREAMING-STOP-ERROR')\n        return\n    \n    try:\n        # Stop streaming\n        can_dev.stream_stop()\n        \n        streaming_active = False\n        print(\"[OI] Stopped streaming\")\n        _send_success(\"Streaming stopped\", 'STREAMING-STOPPED')\n    except Exception as e:\n        _send_error(str(e), 'STREAMING-STOP-ERROR')\n\n\n# ============================================================================\n# Legacy/Deprecated Functions\n# ============================================================================\n\ndef getSysInfo():\n    \"\"\"DEPRECATED: Use getDeviceInfo instead\"\"\"\n    print(\"[OI] Warning: getSysInfo is deprecated, use getDeviceInfo\")\n    getDeviceInfo()\n\n\ndef actionButton(args):\n    \"\"\"DEPRECATED: Use device command functions instead\"\"\"\n    print(f\"[OI] STUB: Handling ACTION-BUTTON: {args}\")\n    _send_error(\"Action button not implemented, use deviceStart/deviceStop instead\", \"ACTION_BUTTON_ERROR\")\n\n\ndef termCmd(args):\n    \"\"\"DEPRECATED: Direct terminal commands not supported\"\"\"\n    print(f\"[OI] STUB: Handling TERM-CMD: {args}\")\n    _send_error(\"Terminal command not implemented\", \"TERM_CMD_ERROR\")\n\n\n# Legacy saveParameters - now uses deviceSave\ndef saveParameters():\n    \"\"\"DEPRECATED: Use deviceSave instead\"\"\"\n    print(\"[OI] Warning: saveParameters is deprecated, use deviceSave\")\n    deviceSave()\n\n\n# ============================================================================\n# CAN Bus Scanning\n# ============================================================================\n\ndef scanCanBus(args=None):\n    \"\"\"\n    Scan CAN bus for OpenInverter devices.\n    \n    Args (dict, optional):\n        node_ids: List of node IDs to scan (default: 1-127)\n        timeout: Timeout per node in seconds (default: 0.1)\n    \n    Returns list of detected nodes with their SDO responses.\n    \"\"\"\n    if not CAN_AVAILABLE or can_dev is None:\n        _send_error(\"CAN not available\", 'CAN-SCAN-ERROR')\n        return\n    \n    node_ids = args.get('node_ids', list(range(1, 128))) if args else list(range(1, 128))\n    timeout = args.get('timeout', 0.1) if args else 0.1\n    \n    print(f\"[OI] Scanning CAN bus for nodes: {node_ids}\")\n    \n    found_nodes = []\n    \n    for node_id in node_ids:\n        try:\n            # Create temporary SDO client for this node\n            temp_sdo = SDOClient(can_dev, node_id=node_id, timeout=timeout)\n            \n            # Try to read a standard parameter (e.g., index 0x1000 - device type)\n            # This is a CANopen standard object that should exist\n            try:\n                device_type = temp_sdo.read(0x1000, 0)\n                \n                # Node responded, add to list\n                found_nodes.append({\n                    'node_id': node_id,\n                    'device_type': device_type,\n                    'responding': True\n                })\n                \n                print(f\"[OI] Found node {node_id} (device type: 0x{device_type:08X})\")\n                \n            except (SDOTimeoutError, SDOAbortError):\n                # Node didn't respond or doesn't have this object\n                pass\n                \n        except Exception as e:\n            print(f\"[OI] Error scanning node {node_id}: {e}\")\n    \n    print(f\"[OI] Scan complete. Found {len(found_nodes)} nodes.\")\n    _send_response('CAN-SCAN-RESULT', {'nodes': found_nodes, 'scanned': len(node_ids)})\n\n",
          "url": "https://raw.githubusercontent.com/jetpax/scripto-studio-registry/main/Apps/OpenInverter/lib/OI_helpers.py"
        }
      ]
    }
  ]
}